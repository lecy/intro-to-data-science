<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Data Structures</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/simplex.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/highlightjs-1.1/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>
<link href="site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 41px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 46px;
  margin-top: -46px;
}

.section h2 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h3 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h4 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h5 {
  padding-top: 46px;
  margin-top: -46px;
}
.section h6 {
  padding-top: 46px;
  margin-top: -46px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>
<script>
$(document).ready(function () {
  window.initializeCodeFolding("hide" === "show");
});
</script>




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Class Design</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    Home
  </a>
</li>
<li>
  <a href="about.html">
    <span class="fa fa-info"></span>
     
    About
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://example.com">
    <span class="fa fa-question fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Data Structures</h1>

</div>


<div id="vectors" class="section level1">
<h1>Vectors</h1>
<p>Vectors are the building blocks of data programming in R, so they are extremely important concepts.</p>
<p>Very loosely speaking a vector is a set of numbers or words. For example, <em>[ 1, 2, 3]</em> or <em>[ apple, orange, pear ]</em>. In social science, a vector is a variable in a dataset.</p>
<p>You will spend a lot of time creating data vectors, transforming variables, generating subsets, cleaning data, and adding new observations. These are all accomplished through operators (commands) that act on vectors.</p>
<p>There are four primary vector types (“classes”) in R:</p>
<table style="width:32%;">
<colgroup>
<col width="15%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th>Class</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>numeric</td>
<td>Typical variable of only numbers</td>
</tr>
<tr class="even">
<td>character</td>
<td>A vector of letters or words, always enclosed with quotes</td>
</tr>
<tr class="odd">
<td>factor</td>
<td>Categories which represent groups, like treatment and control</td>
</tr>
<tr class="even">
<td>logical</td>
<td>A vector of TRUE and FALSE to designate which observations fit a criteria</td>
</tr>
</tbody>
</table>
<p>Each vector or dataset has a “class” that tells R the data type.</p>
<p>These different vectors can be combined into three different types of datasets (data frames, matrices, and lists), which will be discussed below.</p>
<pre class="r"><code>x1 &lt;- c(167,185,119,142)

x1</code></pre>
<pre><code>## [1] 167 185 119 142</code></pre>
<pre class="r"><code>x2 &lt;- c(&quot;adam&quot;,&quot;jamal&quot;,&quot;linda&quot;,&quot;sriti&quot;)

x2</code></pre>
<pre><code>## [1] &quot;adam&quot;  &quot;jamal&quot; &quot;linda&quot; &quot;sriti&quot;</code></pre>
<pre class="r"><code>x3 &lt;- factor( c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;) )

x3</code></pre>
<pre><code>## [1] male   male   female female
## Levels: female male</code></pre>
<pre class="r"><code>x4 &lt;- c( &quot;treatment&quot;,&quot;control&quot;,&quot;treatment&quot;,&quot;control&quot; )

x4</code></pre>
<pre><code>## [1] &quot;treatment&quot; &quot;control&quot;   &quot;treatment&quot; &quot;control&quot;</code></pre>
<pre class="r"><code>is.treat &lt;- x4 == &quot;treatment&quot;

dat &lt;- data.frame( name=x2, sex=x3, treat=x4, strength=x1 )

dat</code></pre>
<pre><code>##    name    sex     treat strength
## 1  adam   male treatment      167
## 2 jamal   male   control      185
## 3 linda female treatment      119
## 4 sriti female   control      142</code></pre>
<pre class="r"><code># R keeps track of the data type of each object

class( x1 )</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>class( x2 )</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>class( x3 )</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<pre class="r"><code>class( is.treat )</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<pre class="r"><code>class( dat )</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<p>We often need to know how many elements belong to a vector, which we find with the <strong>length()</strong> function.</p>
<pre class="r"><code>x1</code></pre>
<pre><code>## [1] 167 185 119 142</code></pre>
<pre class="r"><code>length( x1 )</code></pre>
<pre><code>## [1] 4</code></pre>
<div id="casting" class="section level2">
<h2>Casting</h2>
<p>You can easily move from one data type to another by <em>casting</em> a specific type as another type:</p>
<pre class="r"><code>x &lt;- 1:5

x</code></pre>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<pre class="r"><code>as.character(x)</code></pre>
<pre><code>## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot;</code></pre>
<pre class="r"><code>y &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE)

y</code></pre>
<pre><code>## [1]  TRUE FALSE  TRUE  TRUE FALSE</code></pre>
<pre class="r"><code>as.numeric( y )</code></pre>
<pre><code>## [1] 1 0 1 1 0</code></pre>
<pre class="r"><code>as.character( y )</code></pre>
<pre><code>## [1] &quot;TRUE&quot;  &quot;FALSE&quot; &quot;TRUE&quot;  &quot;TRUE&quot;  &quot;FALSE&quot;</code></pre>
<p>But in some cases it might not make sense to cast one variable type as another.</p>
<pre class="r"><code>z &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

z</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<pre class="r"><code>as.numeric( z )</code></pre>
<pre><code>## Warning: NAs introduced by coercion</code></pre>
<pre><code>## [1] NA NA NA</code></pre>
<p>Casting will often be induced when you try to combine different types of data. For example, when you add a character element to a numeric vector, the whole vector will be cast as a character vector.</p>
<pre class="r"><code>x10 &lt;- 1:5

x10</code></pre>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<pre class="r"><code>x11 &lt;- c( x10, &quot;a&quot;)

x11</code></pre>
<pre><code>## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;a&quot;</code></pre>
<p>When you read data in from outside sources, the input functions often will cast numeric vectors as factors if they contain a low number of elements. See the section on factors below for special instrucdtions on moving from factors to numeric vectors.</p>
</div>
<div id="the-combine-function" class="section level2">
<h2>The Combine Function</h2>
<p>We often need to combine several elements into a single vector, or two vectors to form one. This is done using the <strong>c()</strong> function.</p>
<pre class="r"><code>c(1,2,3)</code></pre>
<pre><code>## [1] 1 2 3</code></pre>
<pre class="r"><code>c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<pre class="r"><code>x &lt;- 1:5
y &lt;- 10:15

z &lt;- c(x,y)

z</code></pre>
<pre><code>##  [1]  1  2  3  4  5 10 11 12 13 14 15</code></pre>
<pre class="r"><code>c(x,&quot;a&quot;)</code></pre>
<pre><code>## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;a&quot;</code></pre>
<p>Often times in programming we want to systematically expand a vector by appending new elements to the end. We do this with the combine function.</p>
<pre class="r"><code>x &lt;- 1

x</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>for( i in 5:10 )
  {
     x &lt;- c(x,i)
     print(x)
  }</code></pre>
<pre><code>## [1] 1 5
## [1] 1 5 6
## [1] 1 5 6 7
## [1] 1 5 6 7 8
## [1] 1 5 6 7 8 9
## [1]  1  5  6  7  8  9 10</code></pre>
</div>
<div id="numeric-vectors" class="section level2">
<h2>Numeric Vectors</h2>
<p>There are some specific things to note about each vector type.</p>
<p>Math operators will only work on numeric vectors.</p>
<pre class="r"><code>summary( x1 )</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   119.0   136.2   154.5   153.2   171.5   185.0</code></pre>
<pre class="r"><code># if we run this, we get an error
# sum( x2 )
# Error in sum(x2) : invalid &#39;type&#39; (character) of argument</code></pre>
<p>The integer vector is a special type of numeric vector. It is used to save memory since integers require less space than numbers that contain decimals points (you need to allocate space for the numbers to the left and the numbers to the right of the decimal). Google “computer memory allocation” is you are interested in the specifics.</p>
<p>If you are doing advanced programming you will be more sensitive to memory allocation and the speed of your code, but in the intro class we will not differentiate between the two types of number vectors. For all practical purposes they do the same thing.</p>
<pre class="r"><code>n.vec &lt;- 1:5

n.vec</code></pre>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<pre class="r"><code>class( n.vec )</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>n.vec[ 2 ] &lt;- 2.01

n.vec</code></pre>
<pre><code>## [1] 1.00 2.01 3.00 4.00 5.00</code></pre>
<pre class="r"><code>class( n.vec )</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
</div>
<div id="character-vectors" class="section level2">
<h2>Character Vectors</h2>
<p>The most important rule to remember with this data type: when creating character vectors, all text must be enclosed by quotation marks.</p>
<pre class="r"><code>c( &quot;a&quot;, &quot;b&quot;, &quot;c&quot; )   # this works</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<pre class="r"><code># c( a, b, c )       # this doesn&#39;t work
# Error: object &#39;a&#39; not found</code></pre>
<p>When you type characters surrounded by quotes then R knows you are creating new text (“strings” in programming speak). When you type characters that are not surrounded by quotes, R thinks that you are looking for an object in the environment, like the variables we have already created. It gets confused when it doesn’t find the object that you typed.</p>
<p>In generate, you will use quotes when you are creating character vectors, and for arguments in functions. You do not use quotes when you are referencing an active object.</p>
<pre class="r"><code>ls()   # these are all of the active objects</code></pre>
<pre><code>##  [1] &quot;dat&quot;      &quot;i&quot;        &quot;is.treat&quot; &quot;n.vec&quot;    &quot;x&quot;        &quot;x1&quot;      
##  [7] &quot;x10&quot;      &quot;x11&quot;      &quot;x2&quot;       &quot;x3&quot;       &quot;x4&quot;       &quot;y&quot;       
## [13] &quot;z&quot;</code></pre>
<pre class="r"><code>&quot;x1&quot;</code></pre>
<pre><code>## [1] &quot;x1&quot;</code></pre>
<pre class="r"><code>x1</code></pre>
<pre><code>## [1] 167 185 119 142</code></pre>
<pre class="r"><code>plot( x1, col=&quot;blue&quot;, pch=19, cex=4 )   # text used for color argument, use quotes</code></pre>
<p><img src="Lecture_02-00_Data_Structures_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code># what if we want colors that represent groups in our data

plot( x1, col=x3, pch=19, cex=4 )       # object used for color argument, no quotes</code></pre>
<p><img src="Lecture_02-00_Data_Structures_files/figure-html/unnamed-chunk-11-2.png" width="672" /></p>
<p>Recall that x3 is the sex of study participants, so the different colors represent the different genders in the study.</p>
</div>
<div id="logical-vectors" class="section level2">
<h2>Logical Vectors</h2>
<p>Logical vectors are collections of a set of TRUE and FALSE statements.</p>
<p>Logical statements allow us to define groups based upon criteria, then decide whether observations belong to the group. See the section on <strong>operators</strong> below for a complete list of logical statements.</p>
<p>Logical vectors are important because organizing data into these sets is what drives all of the advanced data analytics (set theory is at the basis of mathematics and computer science).</p>
<pre class="r"><code>dat</code></pre>
<pre><code>##    name    sex     treat strength
## 1  adam   male treatment      167
## 2 jamal   male   control      185
## 3 linda female treatment      119
## 4 sriti female   control      142</code></pre>
<pre class="r"><code>dat$name == &quot;sriti&quot;</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE</code></pre>
<pre class="r"><code>dat$sex == &quot;male&quot;</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE</code></pre>
<pre class="r"><code>dat$strength &gt; 180</code></pre>
<pre><code>## [1] FALSE  TRUE FALSE FALSE</code></pre>
<p>Typically logical vectors are used in combination with subset operators to identify specific groups in the data.</p>
<pre class="r"><code>dat</code></pre>
<pre><code>##    name    sex     treat strength
## 1  adam   male treatment      167
## 2 jamal   male   control      185
## 3 linda female treatment      119
## 4 sriti female   control      142</code></pre>
<pre class="r"><code># isolate data on all of the females in the dataset

dat[ dat$sex == &quot;female&quot; , ]</code></pre>
<pre><code>##    name    sex     treat strength
## 3 linda female treatment      119
## 4 sriti female   control      142</code></pre>
<p>When defining logical vectors, you can use the abbreviated versions of T for TRUE and F for FALSE.</p>
<pre class="r"><code>z1 &lt;- c(T,T,F,T,F,F)

z1</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE</code></pre>
<p>Note how NAs affect complex logical statements:</p>
<pre class="r"><code>TRUE &amp; TRUE</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>TRUE &amp; FALSE</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>TRUE &amp; NA</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>FALSE &amp; NA</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>If one condition is TRUE, and another is NA, R does not want to throw out the data because the state of the missing value is unclear. As a result, it will preserve the observation, but it will replace all of the data with missing values:</p>
<pre class="r"><code>dat</code></pre>
<pre><code>##    name    sex     treat strength
## 1  adam   male treatment      167
## 2 jamal   male   control      185
## 3 linda female treatment      119
## 4 sriti female   control      142</code></pre>
<pre class="r"><code>keep.these &lt;- c(T,F,NA,F)

dat[ keep.these , ]</code></pre>
<pre><code>##    name  sex     treat strength
## 1  adam male treatment      167
## NA &lt;NA&gt; &lt;NA&gt;      &lt;NA&gt;       NA</code></pre>
<p>To remove these rows, replace all NAs in your selector vector with FALSE:</p>
<pre class="r"><code>keep.these[ is.na(keep.these) ] &lt;- FALSE

dat[ keep.these , ]</code></pre>
<pre><code>##   name  sex     treat strength
## 1 adam male treatment      167</code></pre>
</div>
<div id="factors" class="section level2">
<h2>Factors</h2>
<p>When there are categorical variables within our data, or groups, then we use a special vector to keep track of these groups. We could just use numbers (1=female, 0=male) or characters (“male”,“female”), but factors are useful for two reasons.</p>
<p>First, it saves memory. Text is very “expensive” in terms of memory allocation and processing speed, so using simpler data structure makes R faster.</p>
<p>Second, when a variable is set as a factor, R recognizes that it represents a group and it can deploy object-oriented functionality. When you use a factor in analysis, R knows that you want to split the analysis up by groups.</p>
<pre class="r"><code>height &lt;- c( 70, 68, 62, 64, 72, 69, 58, 63  )

strength &lt;- c(167,185,119,142,175,204,124,117)

sex &lt;- factor( c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;,&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot; ) )

plot( height, strength )   # simple scatter plot</code></pre>
<p><img src="Lecture_02-00_Data_Structures_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<pre class="r"><code>plot( sex, strength )      # box and whisker plot       </code></pre>
<p><img src="Lecture_02-00_Data_Structures_files/figure-html/unnamed-chunk-18-2.png" width="672" /></p>
<p>Factors are more memory efficient than character vectors because they store the underlying data as a numeric vector instead of a categorical (text) vector. Each group in the data is assigned a number, and when printing items the program only has to remember which group corresponds to which number:</p>
<pre class="r"><code>sex</code></pre>
<pre><code>## [1] male   male   female female male   male   female female
## Levels: female male</code></pre>
<pre class="r"><code>as.numeric( sex )</code></pre>
<pre><code>## [1] 2 2 1 1 2 2 1 1</code></pre>
<pre class="r"><code>#  male = 2
#  female = 1</code></pre>
<p>If you print a factor, the computer just replaces each category designation with its name (2 would be replaced with “male” in this example). These replacements can be done in real time without clogging the memory of your computer as they don’t need to be saved.</p>
<p>In some instances a categorical variable might be represented by numbers. For example, grades 9-12 for high school kids. The <strong>very important</strong> rule to remember with factors is you can’t move directly from the factor to numeric using the <strong>as.numeric()</strong> casting function. This will give you the underlying data structure, but will not give you the category names. To get these, you need the <strong>as.character</strong> casting function.</p>
<pre class="r"><code>grades &lt;- sample( x=9:12, size=10, replace=T )

grades</code></pre>
<pre><code>##  [1] 12  9  9 12  9 12 10 12 12 11</code></pre>
<pre class="r"><code>grades &lt;- as.factor( grades )

grades</code></pre>
<pre><code>##  [1] 12 9  9  12 9  12 10 12 12 11
## Levels: 9 10 11 12</code></pre>
<pre class="r"><code>as.numeric( grades )</code></pre>
<pre><code>##  [1] 4 1 1 4 1 4 2 4 4 3</code></pre>
<pre class="r"><code>as.character( grades )</code></pre>
<pre><code>##  [1] &quot;12&quot; &quot;9&quot;  &quot;9&quot;  &quot;12&quot; &quot;9&quot;  &quot;12&quot; &quot;10&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot;</code></pre>
<pre class="r"><code># to get back to the original numeric vector

as.numeric( as.character( grades ))</code></pre>
<pre><code>##  [1] 12  9  9 12  9 12 10 12 12 11</code></pre>
<p>Note that when subsetting a factor, it will retain all of the original levels, even when they are not in use.</p>
<p>In this example, there are 37 teams in the Lahman dataset (some of them defunct) and 16 teams in the National League in 2002. But after applying the year and league subsets you will still have 37 levels.</p>
<pre class="r"><code>library( Lahman )
data( Salaries )
# there are only 16 teams in the NL in 2002

sals.2002 &lt;- Salaries[ Salaries$yearID==&quot;2002&quot;, ]
nl.sals &lt;- sals.2002[ sals.2002$lgID == &quot;NL&quot;, ]
levels( nl.sals$teamID )</code></pre>
<pre><code>##  [1] &quot;ANA&quot; &quot;ARI&quot; &quot;ATL&quot; &quot;BAL&quot; &quot;BOS&quot; &quot;CAL&quot; &quot;CHA&quot; &quot;CHN&quot; &quot;CIN&quot; &quot;CLE&quot; &quot;COL&quot;
## [12] &quot;DET&quot; &quot;FLO&quot; &quot;HOU&quot; &quot;KCA&quot; &quot;LAA&quot; &quot;LAN&quot; &quot;MIA&quot; &quot;MIL&quot; &quot;MIN&quot; &quot;ML4&quot; &quot;MON&quot;
## [23] &quot;NYA&quot; &quot;NYN&quot; &quot;OAK&quot; &quot;PHI&quot; &quot;PIT&quot; &quot;SDN&quot; &quot;SEA&quot; &quot;SFN&quot; &quot;SLN&quot; &quot;TBA&quot; &quot;TEX&quot;
## [34] &quot;TOR&quot; &quot;WAS&quot;</code></pre>
<p>After applying a subset, in order to remove the unused factor levels you need to apply either droplevels(), or else recast your factor as a new factor.</p>
<p>For example:</p>
<pre class="r"><code>sals.2002 &lt;- Salaries [Salaries$yearID==&quot;2002&quot;, ]

nl.sals &lt;- sals.2002 [ sals.2002$lgID == &quot;NL&quot;,]
levels( nl.sals$teamID )</code></pre>
<pre><code>##  [1] &quot;ANA&quot; &quot;ARI&quot; &quot;ATL&quot; &quot;BAL&quot; &quot;BOS&quot; &quot;CAL&quot; &quot;CHA&quot; &quot;CHN&quot; &quot;CIN&quot; &quot;CLE&quot; &quot;COL&quot;
## [12] &quot;DET&quot; &quot;FLO&quot; &quot;HOU&quot; &quot;KCA&quot; &quot;LAA&quot; &quot;LAN&quot; &quot;MIA&quot; &quot;MIL&quot; &quot;MIN&quot; &quot;ML4&quot; &quot;MON&quot;
## [23] &quot;NYA&quot; &quot;NYN&quot; &quot;OAK&quot; &quot;PHI&quot; &quot;PIT&quot; &quot;SDN&quot; &quot;SEA&quot; &quot;SFN&quot; &quot;SLN&quot; &quot;TBA&quot; &quot;TEX&quot;
## [34] &quot;TOR&quot; &quot;WAS&quot;</code></pre>
<pre class="r"><code># fix in one of two equivalent ways:
#
# nl.sals$teamID &lt;- droplevels( nl.sals$teamID )
# nl.sals$teamID &lt;- factor( nl.sals$teamID )

levels( nl.sals$teamID )</code></pre>
<pre><code>##  [1] &quot;ANA&quot; &quot;ARI&quot; &quot;ATL&quot; &quot;BAL&quot; &quot;BOS&quot; &quot;CAL&quot; &quot;CHA&quot; &quot;CHN&quot; &quot;CIN&quot; &quot;CLE&quot; &quot;COL&quot;
## [12] &quot;DET&quot; &quot;FLO&quot; &quot;HOU&quot; &quot;KCA&quot; &quot;LAA&quot; &quot;LAN&quot; &quot;MIA&quot; &quot;MIL&quot; &quot;MIN&quot; &quot;ML4&quot; &quot;MON&quot;
## [23] &quot;NYA&quot; &quot;NYN&quot; &quot;OAK&quot; &quot;PHI&quot; &quot;PIT&quot; &quot;SDN&quot; &quot;SEA&quot; &quot;SFN&quot; &quot;SLN&quot; &quot;TBA&quot; &quot;TEX&quot;
## [34] &quot;TOR&quot; &quot;WAS&quot;</code></pre>
<pre class="r"><code>nl.sals$teamID &lt;- droplevels( nl.sals$teamID )
levels( nl.sals$teamID )</code></pre>
<pre><code>##  [1] &quot;ARI&quot; &quot;ATL&quot; &quot;CHN&quot; &quot;CIN&quot; &quot;COL&quot; &quot;FLO&quot; &quot;HOU&quot; &quot;LAN&quot; &quot;MIL&quot; &quot;MON&quot; &quot;NYN&quot;
## [12] &quot;PHI&quot; &quot;PIT&quot; &quot;SDN&quot; &quot;SFN&quot; &quot;SLN&quot;</code></pre>
</div>
<div id="generating-vectors" class="section level2">
<h2>Generating Vectors</h2>
<p>You will often need to generate vectors for data transformations or simulations. Here are the most common functions that will be helpful.</p>
<pre class="r"><code># repeat a number, or series of numbers

rep( x=9, times=5 )</code></pre>
<pre><code>## [1] 9 9 9 9 9</code></pre>
<pre class="r"><code>rep( x=c(5,7), times=5 )</code></pre>
<pre><code>##  [1] 5 7 5 7 5 7 5 7 5 7</code></pre>
<pre class="r"><code>rep( x=c(5,7), each=5 )</code></pre>
<pre><code>##  [1] 5 5 5 5 5 7 7 7 7 7</code></pre>
<pre class="r"><code>rep( x=c(&quot;treatment&quot;,&quot;control&quot;), each=5 )  # also works to create categories</code></pre>
<pre><code>##  [1] &quot;treatment&quot; &quot;treatment&quot; &quot;treatment&quot; &quot;treatment&quot; &quot;treatment&quot;
##  [6] &quot;control&quot;   &quot;control&quot;   &quot;control&quot;   &quot;control&quot;   &quot;control&quot;</code></pre>
<pre class="r"><code># create a sequence of numbers

seq( from=1, to=15, by=1 )</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</code></pre>
<pre class="r"><code>seq( from=1, to=15, by=3 )</code></pre>
<pre><code>## [1]  1  4  7 10 13</code></pre>
<pre class="r"><code>1:15   # shorthand if by=1</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</code></pre>
<pre class="r"><code># create a random sample

hat &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;f&quot;)

sample( x=hat, size=3, replace=FALSE )</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;f&quot; &quot;b&quot;</code></pre>
<pre class="r"><code>sample( x=hat, size=3, replace=FALSE )</code></pre>
<pre><code>## [1] &quot;b&quot; &quot;f&quot; &quot;b&quot;</code></pre>
<pre class="r"><code>sample( x=hat, size=3, replace=FALSE )</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;c&quot; &quot;b&quot;</code></pre>
<pre class="r"><code># for multiple samples use replacement

sample( x=hat, size=10, replace=TRUE )</code></pre>
<pre><code>##  [1] &quot;b&quot; &quot;f&quot; &quot;b&quot; &quot;a&quot; &quot;c&quot; &quot;f&quot; &quot;b&quot; &quot;c&quot; &quot;f&quot; &quot;c&quot;</code></pre>
<pre class="r"><code># create data that follows a normal curve

iq &lt;- rnorm( n=1000, mean=100, sd=15 )

hist( iq, col=&quot;gray&quot; )</code></pre>
<p><img src="Lecture_02-00_Data_Structures_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
</div>
</div>
<div id="operators" class="section level1">
<h1>Operators</h1>
<p>Logical operators are the most basic type of data programming and the core of many types of data analysis. Most of the time we are not conducting fancy statistics, we just want to identify members of a group (print all of the females from the study), or describe things that belong to a subset of the data (compare the average price of houses with garages to houses without garages).</p>
<p>In order to accomplish these simple tasks we need to use logic statements. A logic statement answers the question, does an observation belong to a group.</p>
<p>Many times groups are simple. Show me all of the professions that make over $100k a year, for example.</p>
<p>Sometimes groups are complex. Identify the African American children from a specific zip code in Chicago that live in households with single mothers.</p>
<p>You will use nine basic logical operators:</p>
<table>
<thead>
<tr class="header">
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&lt;</td>
<td>less than</td>
</tr>
<tr class="even">
<td>&lt;=</td>
<td>less than or equal to</td>
</tr>
<tr class="odd">
<td>&gt;</td>
<td>greater than</td>
</tr>
<tr class="even">
<td>&gt;=</td>
<td>greater than or equal to</td>
</tr>
<tr class="odd">
<td>==</td>
<td>exactly equal to</td>
</tr>
<tr class="even">
<td>!=</td>
<td>not equal to</td>
</tr>
<tr class="odd">
<td>x | y</td>
<td>x OR y</td>
</tr>
<tr class="even">
<td>x &amp; y</td>
<td>x AND y</td>
</tr>
<tr class="odd">
<td>!</td>
<td>opposite of</td>
</tr>
</tbody>
</table>
<p>Logical operators create logical vectors, a vector that contains only TRUE or FALSE. The TRUE means that the observation belongs to the group, FALSE means it does not.</p>
<pre class="r"><code>x1 &lt;- c(7,9,1,2)

x2 &lt;- c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;)

x3 &lt;- c(&quot;treatment&quot;,&quot;control&quot;,&quot;treatment&quot;,&quot;control&quot;)

x1 &gt; 7</code></pre>
<pre><code>## [1] FALSE  TRUE FALSE FALSE</code></pre>
<pre class="r"><code>x1 &gt;= 7</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE</code></pre>
<pre class="r"><code>x1 == 9</code></pre>
<pre><code>## [1] FALSE  TRUE FALSE FALSE</code></pre>
<pre class="r"><code>x1 = 9  # don&#39;t use a single equals operator!  it overwrites your variable

x1</code></pre>
<pre><code>## [1] 9</code></pre>
<pre class="r"><code>x1 &lt;- c(7,9,1,2)

x1 == 9 | x1 == 1</code></pre>
<pre><code>## [1] FALSE  TRUE  TRUE FALSE</code></pre>
<pre class="r"><code># x2 == male  # this will not work because male is not enclosed with quotes

x2 == &quot;female&quot;</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE  TRUE</code></pre>
<pre class="r"><code>x2 == &quot;female&quot; &amp; x3 == &quot;treatment&quot;</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE FALSE</code></pre>
<p>Note that we use operators to create logical vectors where TRUE designates observation that belong to the defined group, and FALSE designates observations outside the group. We use these logical vectors in three ways:</p>
<ol style="list-style-type: decimal">
<li>We can create a selector variable that is used for subsets. When a logical vector is passed to the subset function it will keep all observations with a TRUE value, and drop observations with a FALSE value.</li>
</ol>
<pre class="r"><code>x1</code></pre>
<pre><code>## [1] 7 9 1 2</code></pre>
<pre class="r"><code>x1 &gt; 5</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE</code></pre>
<pre class="r"><code>keep.these &lt;- x1 &gt; 5

x1[ keep.these ]</code></pre>
<pre><code>## [1] 7 9</code></pre>
<pre class="r"><code># you can create a selector variable with one variable, and apply it to another

x2[ keep.these ]  # sex of observations where x1 &gt; 5</code></pre>
<pre><code>## [1] &quot;male&quot; &quot;male&quot;</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Logical vectors give us an easy way to count things within defined groups.</li>
</ol>
<p>We can apply a <strong>sum()</strong> function to a logical vector, and the result will be a tally of all of the TRUE cases.</p>
<pre class="r"><code># how many females do we have in our study?

sum( x2 == &quot;female&quot; )</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code># how many females do we have in our treatment group?

sum( x2 == &quot;female&quot; &amp; x3 == &quot;treatment&quot; )</code></pre>
<pre><code>## [1] 1</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>We use selector variables to replace observations with new values using the assignment operator. This is similar to a find and replace operation.</li>
</ol>
<pre class="r"><code>x7 &lt;- c( &quot;mole&quot;,&quot;mouse&quot;,&quot;shrew&quot;,&quot;mouse&quot;,&quot;rat&quot;,&quot;shrew&quot;)

# the lab assistant incorrectly identified the shrews

x7</code></pre>
<pre><code>## [1] &quot;mole&quot;  &quot;mouse&quot; &quot;shrew&quot; &quot;mouse&quot; &quot;rat&quot;   &quot;shrew&quot;</code></pre>
<pre class="r"><code>x7[ x7 == &quot;shrew&quot; ] &lt;- &quot;possum&quot;

x7</code></pre>
<pre><code>## [1] &quot;mole&quot;   &quot;mouse&quot;  &quot;possum&quot; &quot;mouse&quot;  &quot;rat&quot;    &quot;possum&quot;</code></pre>
<pre class="r"><code># we don&#39;t know if linda received the treatment

x3 &lt;- c(&quot;adam&quot;,&quot;jamal&quot;,&quot;linda&quot;,&quot;sriti&quot;)

x4 &lt;- c( &quot;treatment&quot;,&quot;control&quot;,&quot;treatment&quot;,&quot;control&quot;)

x4[ x3 == &quot;linda&quot; ] &lt;- NA

x4</code></pre>
<pre><code>## [1] &quot;treatment&quot; &quot;control&quot;   NA          &quot;control&quot;</code></pre>
<p>The <strong>!</strong> operator is a special case, where it is not used to define a new logical vector, but rather it swaps the values of an existing logical vector.</p>
<pre class="r"><code>x1</code></pre>
<pre><code>## [1] 7 9 1 2</code></pre>
<pre class="r"><code>these &lt;- x1 &gt; 5

these</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE</code></pre>
<pre class="r"><code>! these</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE  TRUE</code></pre>
<pre class="r"><code>! TRUE</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>! FALSE</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="datasets" class="section level1">
<h1>Datasets</h1>
<p>When we combine multiple vectors together, we now have a dataset. There are three main types that we will use in this class.</p>
<table>
<thead>
<tr class="header">
<th>Class</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>data frame</td>
<td>A typical data set comprised of several variables</td>
</tr>
<tr class="even">
<td>matrix</td>
<td>A data set comprised of only numbers, used for matrix math</td>
</tr>
<tr class="odd">
<td>list</td>
<td>The grab bag of data structures - several vectors held together</td>
</tr>
</tbody>
</table>
<div id="data-frames" class="section level2">
<h2>Data Frames</h2>
<p>The most familiar spreadsheet-type data structure is called a data frame in R. It consists of rows, which represent observations, and columns, which represent variables.</p>
<pre class="r"><code>data( USArrests )

head( USArrests )</code></pre>
<pre><code>##            Murder Assault UrbanPop Rape
## Alabama      13.2     236       58 21.2
## Alaska       10.0     263       48 44.5
## Arizona       8.1     294       80 31.0
## Arkansas      8.8     190       50 19.5
## California    9.0     276       91 40.6
## Colorado      7.9     204       78 38.7</code></pre>
<pre class="r"><code>names( USArrests )   # variable names or column names</code></pre>
<pre><code>## [1] &quot;Murder&quot;   &quot;Assault&quot;  &quot;UrbanPop&quot; &quot;Rape&quot;</code></pre>
<pre class="r"><code>row.names( USArrests )</code></pre>
<pre><code>##  [1] &quot;Alabama&quot;        &quot;Alaska&quot;         &quot;Arizona&quot;        &quot;Arkansas&quot;      
##  [5] &quot;California&quot;     &quot;Colorado&quot;       &quot;Connecticut&quot;    &quot;Delaware&quot;      
##  [9] &quot;Florida&quot;        &quot;Georgia&quot;        &quot;Hawaii&quot;         &quot;Idaho&quot;         
## [13] &quot;Illinois&quot;       &quot;Indiana&quot;        &quot;Iowa&quot;           &quot;Kansas&quot;        
## [17] &quot;Kentucky&quot;       &quot;Louisiana&quot;      &quot;Maine&quot;          &quot;Maryland&quot;      
## [21] &quot;Massachusetts&quot;  &quot;Michigan&quot;       &quot;Minnesota&quot;      &quot;Mississippi&quot;   
## [25] &quot;Missouri&quot;       &quot;Montana&quot;        &quot;Nebraska&quot;       &quot;Nevada&quot;        
## [29] &quot;New Hampshire&quot;  &quot;New Jersey&quot;     &quot;New Mexico&quot;     &quot;New York&quot;      
## [33] &quot;North Carolina&quot; &quot;North Dakota&quot;   &quot;Ohio&quot;           &quot;Oklahoma&quot;      
## [37] &quot;Oregon&quot;         &quot;Pennsylvania&quot;   &quot;Rhode Island&quot;   &quot;South Carolina&quot;
## [41] &quot;South Dakota&quot;   &quot;Tennessee&quot;      &quot;Texas&quot;          &quot;Utah&quot;          
## [45] &quot;Vermont&quot;        &quot;Virginia&quot;       &quot;Washington&quot;     &quot;West Virginia&quot; 
## [49] &quot;Wisconsin&quot;      &quot;Wyoming&quot;</code></pre>
<pre class="r"><code>dim( USArrests )   # number of rows by number of columns</code></pre>
<pre><code>## [1] 50  4</code></pre>
</div>
<div id="matrices" class="section level2">
<h2>Matrices</h2>
<p>A matrix is also a rectangular data object that consists of collections of vectors, but it is special in the sense that it only has numeric vectors and no variable names.</p>
<pre class="r"><code>mat &lt;- matrix( 1:20, nrow=5 )

mat</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20</code></pre>
<pre class="r"><code>names( mat )</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code>dim( mat )</code></pre>
<pre><code>## [1] 5 4</code></pre>
<pre class="r"><code>as.data.frame( mat )  # creates variable names</code></pre>
<pre><code>##   V1 V2 V3 V4
## 1  1  6 11 16
## 2  2  7 12 17
## 3  3  8 13 18
## 4  4  9 14 19
## 5  5 10 15 20</code></pre>
<p>These are used almost exclusively for matrix algebra operations, which are fundamental to mathematical statistics. We will not use matrices in this course.</p>
</div>
<div id="lists" class="section level2">
<h2>Lists</h2>
<p>The list is the most flexible data structure. It is created by sticking a bunch of unrelated vectors or datasets together. For example, when you run a regression you generate a bunch of interesting information. This information is saved as a list.</p>
<pre class="r"><code>x &lt;- 1:100
y &lt;- 2*x + rnorm( 100, 0, 10)

m.01 &lt;- lm( y ~ x )

names( m.01 )</code></pre>
<pre><code>##  [1] &quot;coefficients&quot;  &quot;residuals&quot;     &quot;effects&quot;       &quot;rank&quot;         
##  [5] &quot;fitted.values&quot; &quot;assign&quot;        &quot;qr&quot;            &quot;df.residual&quot;  
##  [9] &quot;xlevels&quot;       &quot;call&quot;          &quot;terms&quot;         &quot;model&quot;</code></pre>
<pre class="r"><code>m.01$coefficients</code></pre>
<pre><code>## (Intercept)           x 
##   -1.191003    2.034923</code></pre>
<pre class="r"><code>m.01$residuals</code></pre>
<pre><code>##            1            2            3            4            5 
##   7.18262566   4.72595794 -10.15887696  -2.40025240 -16.15031923 
##            6            7            8            9           10 
##  -2.82921251   1.79480450  -1.99897126  -6.99091683  14.79131479 
##           11           12           13           14           15 
##   5.02157956   4.51334953  11.83893806   2.21206879  -3.86271508 
##           16           17           18           19           20 
##  -7.99079494   7.77861464  15.88438166   4.95188398   2.34910138 
##           21           22           23           24           25 
##  17.78584513 -10.49244397  11.29059096 -18.01330969  16.92825782 
##           26           27           28           29           30 
##   0.02773895  12.65980449 -13.29151816   0.94323889  -5.96870359 
##           31           32           33           34           35 
## -15.31063675 -11.45332767   7.08493648  -0.91015483  -9.19647807 
##           36           37           38           39           40 
##  11.24791365  -1.21240019 -24.59393673   4.67420003 -16.35233460 
##           41           42           43           44           45 
##   4.43355837   9.05527389   3.82022478   8.03039708   9.43988096 
##           46           47           48           49           50 
##  -6.84267373   3.60505830  -6.50954244  -3.63789907  -5.51551328 
##           51           52           53           54           55 
##   3.78006114 -10.00037054  -5.36860821 -12.02458059  -8.18111597 
##           56           57           58           59           60 
##   0.22767725  -3.10304029  -3.77453748  24.02322934   5.78199757 
##           61           62           63           64           65 
##  -2.31684085  10.49496938   1.09810381   5.51277622  -5.80103294 
##           66           67           68           69           70 
##   4.36969859 -10.69369520  -3.75802315   0.69331269  -1.11196779 
##           71           72           73           74           75 
##  -0.09298119   4.00377044  -3.29753387   0.24655040   1.25320720 
##           76           77           78           79           80 
##   1.05298180  12.93883846  -7.37058855  -5.54129859 -21.31789651 
##           81           82           83           84           85 
##  -4.55698376   4.83167325   0.16816889  -9.59076740  11.26245256 
##           86           87           88           89           90 
##  10.84979469  -2.52085543  -8.49207727  -6.25216669   3.35770500 
##           91           92           93           94           95 
##  12.49403740   0.23713266 -11.15703474  -7.22739727  14.69945646 
##           96           97           98           99          100 
## -16.41278555  -1.28050359  10.88765456  17.90236412   6.68846121</code></pre>
<pre class="r"><code>m.01$call</code></pre>
<pre><code>## lm(formula = y ~ x)</code></pre>
<p>These output are all related to the model we have run, so they are kept organized by the list so they can be used for various further steps like comparing models or checking for model fit.</p>
<p>A data frame is a bit more rigid that a list in that you cannot combine elements that do not have the same dimsions.</p>
<pre class="r"><code># new.dataframe &lt;- data.frame( m.01$coefficients, m.01$residuals, m.01$call )
#
# these will fail because the vectors have different lengths </code></pre>
</div>
</div>
<div id="subsets" class="section level1">
<h1>Subsets</h1>
<p>The subset operators <strong>[ ]</strong> are one of the most common you will use in R.</p>
<p>The primary rule of subsets is to use a data operator to create a logical selector vector, and use that to generate subsets. Any observation that corresponds to TRUE will be retained, any observation that corresponds to FALSE will be dropped.</p>
<p>For vectors, you need to specify a single dimension.</p>
<pre class="r"><code>x1 &lt;- c(167,185,119,142)

x2 &lt;- c(&quot;adam&quot;,&quot;jamal&quot;,&quot;linda&quot;,&quot;sriti&quot;)

x3 &lt;- factor( c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;) )

x4 &lt;- c( &quot;treatment&quot;,&quot;control&quot;,&quot;treatment&quot;,&quot;control&quot; )

dat &lt;- data.frame( name=x2, sex=x3, treat=x4, strength=x1 )


these &lt;- x1 &gt; 140     # selector vector

these</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE  TRUE</code></pre>
<pre class="r"><code>x1[ these ]</code></pre>
<pre><code>## [1] 167 185 142</code></pre>
<pre class="r"><code>x2[ these ]</code></pre>
<pre><code>## [1] &quot;adam&quot;  &quot;jamal&quot; &quot;sriti&quot;</code></pre>
<p>For data frames, you need two dimensions (rows and columns). The two dimensions are seperated by a comma, and if you leave one blank you will not drop anything.</p>
<pre class="r"><code># dat[  row position ,  column position  ]

dat </code></pre>
<pre><code>##    name    sex     treat strength
## 1  adam   male treatment      167
## 2 jamal   male   control      185
## 3 linda female treatment      119
## 4 sriti female   control      142</code></pre>
<pre class="r"><code>these &lt;- dat$treat == &quot;treatment&quot;

dat[ these , ]   # all data in the treatment group</code></pre>
<pre><code>##    name    sex     treat strength
## 1  adam   male treatment      167
## 3 linda female treatment      119</code></pre>
<pre class="r"><code>dat[ , c(&quot;name&quot;,&quot;sex&quot;) ]  # select two columns of data</code></pre>
<pre><code>##    name    sex
## 1  adam   male
## 2 jamal   male
## 3 linda female
## 4 sriti female</code></pre>
<pre class="r"><code># to keep a subset as a separate dataset

dat.women &lt;- dat[ dat$sex == &quot;female&quot; , ]

dat.women</code></pre>
<pre><code>##    name    sex     treat strength
## 3 linda female treatment      119
## 4 sriti female   control      142</code></pre>
<p>Note the rules listed above about subsetting factors. After applying a subset, they will retain all of the original levels, even when they are not longer useful. You need to drop the unused levels if you would like them to be omitted from functions that use the factor levels for analysis.</p>
<pre class="r"><code>df &lt;- data.frame( letters=LETTERS[1:5], numbers=seq(1:5) )

levels( df$letters )</code></pre>
<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot;</code></pre>
<pre class="r"><code>sub.df &lt;- df[ 1:3, ]

sub.df$letters</code></pre>
<pre><code>## [1] A B C
## Levels: A B C D E</code></pre>
<pre class="r"><code>levels( sub.df$letters )</code></pre>
<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot;</code></pre>
<pre class="r"><code>droplevels( sub.df$letters )</code></pre>
<pre><code>## [1] A B C
## Levels: A B C</code></pre>
<pre class="r"><code>sub.df$letters &lt;- droplevels( sub.df$letters )</code></pre>
</div>
<div id="variable-transformations" class="section level1">
<h1>Variable Transformations</h1>
<p>When we create a new variable from existing variables, it is called a ‘transformation’. This is very common in data science. Crime is measures by the number of assults <em>per 100,000 people</em>, for example (crime / pop). A batting average is the number of hits divided by the number of at bats.</p>
<p>In R, mathematical operations are <em>vectorized</em>, which means that operations are performed on the entire vector all at once. This makes transformations fast and easy.</p>
<pre class="r"><code>x &lt;- 1:10

x + 5</code></pre>
<pre><code>##  [1]  6  7  8  9 10 11 12 13 14 15</code></pre>
<pre class="r"><code>x * 5</code></pre>
<pre><code>##  [1]  5 10 15 20 25 30 35 40 45 50</code></pre>
<p>R uses a convention called “recycling”, which means that it will re-use elements of a vector if necessary. In the example below the x vector has 10 elements, but the y vector only has 5 elements. When we run out of y, we just start over from the beginning. This is powerful in some instances, but can be dangerous in others if you don’t realize that that it is happening.</p>
<pre class="r"><code>x &lt;- 1:10

y &lt;- 1:5

x + y</code></pre>
<pre><code>##  [1]  2  4  6  8 10  7  9 11 13 15</code></pre>
<pre class="r"><code>x * y</code></pre>
<pre><code>##  [1]  1  4  9 16 25  6 14 24 36 50</code></pre>
<pre class="r"><code># the colors are recycled

plot( 1:5, 1:5, col=c(&quot;red&quot;,&quot;blue&quot;), pch=19, cex=3 )</code></pre>
<p><img src="Lecture_02-00_Data_Structures_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
<p>Here is an example of recycling gone wrong:</p>
<pre class="r"><code>x1 &lt;- c(167,185,119,142)

x2 &lt;- c(&quot;adam&quot;,&quot;jamal&quot;,&quot;linda&quot;,&quot;sriti&quot;)

x3 &lt;- c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;)

x4 &lt;- c( &quot;treatment&quot;,&quot;contro&quot;,&quot;treatment&quot;,&quot;control&quot; )

dat &lt;- data.frame( name=x2, sex=x3, treat=x4, strength=x1 )


# create a subset of data of all female study participants

dat$sex == &quot;female&quot;</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE  TRUE</code></pre>
<pre class="r"><code>these &lt;- dat$sex == &quot;female&quot;

dat[ these, ]  # correct subset</code></pre>
<pre><code>##    name    sex     treat strength
## 3 linda female treatment      119
## 4 sriti female   control      142</code></pre>
<pre class="r"><code># same thing, but i mess is up - the female element is recycled in the overwrite

dat$sex = &quot;female&quot;    # whoops just over-wrote my data! should be double equal

these &lt;- dat$sex == &quot;female&quot; 

dat[ these , ]</code></pre>
<pre><code>##    name    sex     treat strength
## 1  adam female treatment      167
## 2 jamal female    contro      185
## 3 linda female treatment      119
## 4 sriti female   control      142</code></pre>
</div>
<div id="missing-values-nas" class="section level1">
<h1>Missing Values: NA’s</h1>
<p>Missing values are coded differently in each data analysis program. SPSS uses a period, for example. In R, missing values are coded as “NA”.</p>
<p>The important thing to note is that R wants to make sure you know there are missing values if you are conducting analysis. As a result, it will give you the answer of “NA” when you try to do math with a vector that includes a missing value. You have to ask it explicitly to ignore the missing value.</p>
<pre class="r"><code>x5 &lt;- c( 1, 2, 3, 4 )

x5</code></pre>
<pre><code>## [1] 1 2 3 4</code></pre>
<pre class="r"><code>sum( x5 )</code></pre>
<pre><code>## [1] 10</code></pre>
<pre class="r"><code>mean( x5 )</code></pre>
<pre><code>## [1] 2.5</code></pre>
<pre class="r"><code>x5 &lt;- c( 1, 2, NA, 4 )

x5</code></pre>
<pre><code>## [1]  1  2 NA  4</code></pre>
<pre class="r"><code># should missing values be treated as zeros or dropped? 

sum( x5 )</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>mean( x5 )</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>sum( x5, na.rm=T )   # na.rm=T argument drops missing values</code></pre>
<pre><code>## [1] 7</code></pre>
<pre class="r"><code>mean( x5, na.rm=T )  # na.rm=T argument drops missing values</code></pre>
<pre><code>## [1] 2.333333</code></pre>
<p>You cannot use the <em>==</em> operator to identify missing values in a dataset. There is a special <strong>is.na()</strong> function to locate all of the missing values in a vector.</p>
<pre class="r"><code>x5</code></pre>
<pre><code>## [1]  1  2 NA  4</code></pre>
<pre class="r"><code>x5 == NA    # this does not do what you want</code></pre>
<pre><code>## [1] NA NA NA NA</code></pre>
<pre class="r"><code>is.na( x5 )    # much better</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE FALSE</code></pre>
<pre class="r"><code>! is.na( x5 )  # if you want to create a selector vector to drop missing values </code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE  TRUE</code></pre>
<pre class="r"><code>x5[ ! is.na(x5) ]</code></pre>
<pre><code>## [1] 1 2 4</code></pre>
<pre class="r"><code>x5[ is.na(x5) ] &lt;- 0  # replace missing values with zero</code></pre>
</div>
<div id="the-attach-function-never-use-this-in-scripts" class="section level1">
<h1>The ‘attach’ Function (Never Use This in Scripts)</h1>
<p>This is a convenient function for making variable names easily accessible, but it is problematic because of:</p>
<p>scope</p>
<p>conflicting variable names</p>
<pre class="r"><code>x &lt;- 1:5
y &lt;- 6:10

dat &lt;- data.frame(x,y)

rm(x)
rm(y)


# I want to transform x in my dataset

attach( dat )

2*x</code></pre>
<pre><code>## [1]  2  4  6  8 10</code></pre>
<pre class="r"><code>x &lt;- 2*x

detach( dat )

x</code></pre>
<pre><code>## [1]  2  4  6  8 10</code></pre>
<pre class="r"><code>dat  # whoops! I didn&#39;t save my work in the dataset</code></pre>
<pre><code>##   x  y
## 1 1  6
## 2 2  7
## 3 3  8
## 4 4  9
## 5 5 10</code></pre>
<p>In general, try not to use the <strong>attach()</strong> function.</p>
</div>

<p>Copyright &copy; 201 Yourmom, Inc. All rights reserved.</p>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
